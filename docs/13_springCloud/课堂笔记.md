# 今日授课目标：


能够理解SpringCloud作用【重点】

能够搭建Eureka注册中心服务

能够理解Ribbon负载均衡的作用【重点】

能够测试Ribbon负载均衡访问效果：随机和轮询

能够理解Hystrix熔断器的作用【重点】

能够写出Hystrix熔断器服务降级方法

# 一、系统架构演变过程

   - 单一应用架构
   - 垂直应用架构
   - 分布式服务架构
   - 面向服务的架构：微服务架构

# 二、SpringCloud介绍

## 什么是SpringCloud？

是一系列框架的有序集合，包含了服务注册发现，配置中心，消息总线，负载均衡，断路器等

## 为什么要用Springcloud？

从架构层面降低了对大型分布式系统构建的要求和难度

## 基础架构图剖析-版本介绍
   - 版本介绍-Greenwich SR1
     - 快照版 -SNAPSHOT
     - 里程碑版本-MileStone，M1-->M9
     - 正式的，稳定发行版本-SR，Service Release，GA（Generally Available）
   - Spring Cloud与SpringBoot版本的对应关系
        - Greenwich SR1  --->  2.1.x

# 三、微服务业务场景的构建
   - 创建父工程
   - 创建父工程的子模块，消费者，SpringBoot的工程，只有web
   - 创建父工程的子模块，提供者，Spring Boot的工程， Mybatis+Web

## 微服务业务场景问题思考

**实现最简单的需求：消费者访问提供者的查询用户信息接口**

实现步骤：

1. 在启动引导类注册RestTemplate对象到SpringIOC容器
2. 在ConsumerController中，用RestTemplate请求服务提供者查询用户信息接口
3. 启动消费者工程并测试

思考存在的问题：

   - 在消费者服务中，访问提供者服务URL地址硬编码，万一地址端口变化了怎么办？提供者服务死掉了消费者怎么才能知道？
     
     - 在消费者服务中，是不清楚服务提供者状态的！
   - 为了增加服务提供者的并发访问量，我们搭建集群，集群的负载均衡怎么实现？
   - 服务提供者如果出现故障，会不会向用户抛出异常页面，该不该抛出错误页面？

# 四、Spring Cloud Eureka 注册中心

## 什么是注册中心Eureka？

- 是一个服务注册和发现，以及服务治理的微服务套件。
- 由两个部分构成
  - 服务端组件注册中心：服务治理
  - 客户端组件：服务注册，服务发现

## 注册中心搭建-界面介绍

   - 目标：搭建注册中心
   - 实现步骤：
     1. 创建SpringBoot工程eureka_server
     2. 勾选starter：DevTools和EurekaServer
     3. 启动引导类上加注解@EnableEurekaServer
     4. 配置文件：端口，应用名称，注册中心地址
     5. 启动注册中心服务
     6. 测试注册中心服务
   - 界面简介

## 注册中心-知识点详解

1. 基础架构的三个角色：注册中心，消费者，提供者
2. 服务注册（register）：Eureka Client会通过发送REST请求的方式向Server注册自己的服务
3. 服务续约（renew）：心跳检测，定时续约服务，默认30秒
4. 获取服务（get registry）：获取注册中心所有服务的清单信息，本地有缓存(存储在DiscoveryClient对象中)，缓存时间默认30秒
5. 服务调用：通过清单查阅要调用的服务，然后进行远程调用
6. 服务下线（cancel）：服务正常关闭和重启，告知注册中心自己下线的过程
7. 失效剔除（evict）：如果服务没有来得及告诉注册中心就死了，那么等着被剔除吧！
8. 自我保护：避免了大面积网络故障导致的本不应该的服务被剔除！默认自我保护功能是开启

## 服务注册到注册中心

   - 目标：提供者和消费者服务注册到注册中心
   - 实现步骤：
     1. 改造服务提供者，pom文件中加入Eureka客户端的starter依赖
     2. 启动引导类上加@EnableDiscoveryClient注解
     3. 配置文件：端口，应用名称，服务注册中心地址
     4. 重启项目
     5. 在注册中心管理平台查看已成功注册的服务

## 再次实现消费者访问服务提供者

这次是通过注册中心的注册列表来访问

**目标：消费者访问服务提供者**

**实现步骤：**

1. 在ConsumerController中注入DiscoveryClient对象
2. 通过DiscoveryClient获取服务列表，从服务列表中获取用户服务(user-service)
3. 用户服务实例中获取请求地址，请求端口，实现动态地址拼接
4. RestTemplate发送请求，获取响应
5. 启动消费者工程并测试

# 五、Spring Cloud Ribbon 负载均衡

   - 什么是Ribbon？
      - 它是一个工具类框架，实现了http请求的负载均衡。它是微服务的基础设施，非常重要，很多其他组件都是基于它实现的，比如说feign，比如说API网关gateway...。

   - 负载均衡算法扩展介绍：AvailabilityFilteringRule(根据当前服务是否熔断及并发情况进行负载均衡的算法)、WeightedResponseTimeRule(根据服务响应时间来负载均衡的算法)

## 实现负载均衡入门案例

**目标：实现负载均衡访问用户服务小集群。**

**实现步骤：**

第一步：启动多个user_service服务

1.  修改配置文件端口获取方式
2.  编辑应用启动配置
3.  启动两个提供者服务
4.  在注册中心查询是否启动成功

第二步：开启消费者负载均衡

1.  在RestTemplate的注入方法上加入@LoadBalanced注解
2.  修改调用请求的Url地址，改为服务名称调用
3.  访问页面查看效果

## 负载均衡源码解析
为什么只输入了Service名称就可以访问了呢？不应该需要获取ip和端口吗？

源码类：LoadBalancerInterceptor

# 六、Spring Cloud Hystrix 熔断器
- 什么是Hystrix熔断器？
  - 分布式环境中，帮助控制服务之间级联报错的一个延迟和容错的库。提高系统整体弹性。
- 雪崩效应：查看讲义PPT内容

## 熔断器原理分析

熔断器的原理如同电力过载保护器

有三种状态

- 关闭状态：所有请求正常访问
- 打开状态：所有请求被降级
- 半开状态：打开状态不是永久的，打开之后过了休眠时间会进入半开状态，半开状态效验服务

什么时候熔断？

1. 访问超时
2. 服务不可用(死了)
3. 服务抛出异常(虽然有异常但还活着)
4. 其他请求导致服务异常到达阈值，所有服务都会被降级

## 熔断器配置文件解析

```yml
# 配置熔断策略：
# 强制打开熔断器 默认false关闭的。测试配置是否生效
hystrix.command.default.circuitBreaker.forceOpen: false
# 触发熔断错误比例阈值，默认值50%
hystrix.command.default.circuitBreaker.errorThresholdPercentage: 20
# 熔断后休眠时长，默认值5秒
hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds: 60000
# 熔断触发最小请求次数，默认值是20
hystrix.command.default.circuitBreaker.requestVolumeThreshold: 5
# 熔断超时设置，默认为1秒
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 2000
```

断策略超时效果演示

## 熔断器全局服务降级方法
- 目标：体验全局服务降级方法
- 实现步骤：
    1. 在controller类上加@DefaultProperties(defaultFallback=”defaultFallBack“)注解
    2. 在方法上加@HystrixCommon注解
    3. 重启服务测试测试

# 总结：

能够理解SpringCloud作用【重点】

能够搭建Eureka注册中心服务

能够理解Ribbon负载均衡的作用【重点】

能够测试Ribbon负载均衡访问效果：随机和轮询

能够理解Hystrix熔断器的作用【重点】

能够写出Hystrix熔断器服务降级方法

## 课后练习

## 1、搭建微服务业务场景：三个工程，父工程，消费者工程，提供者工程。

## 2、搭建注册中心微服务，查看注册中心控制界面，并将消费者和提供者注册到注册中心。

## 3、搭建2个用户服务的集群，通过负载均衡访问。

## 4、编写服务降级方法，测试服务降级效果。

# 昨日内容回顾

回顾：

- 什么是Spring Cloud?
  - 它是一系列框架的有序集合，利用SpringBoot开发的便利巧妙的简化了分布式系统的开发。常用的有负载均衡器、断路器、注册中心、配置中心、消息总线。
  - **Spring Cloud 从架构层面降低了大型分布式系统的构建难度和要求**
- 微服务业务场景中，必然面临的问题有什么？
  - 服务治理、负载均衡、容错、远程调用
  - **除此之外还有今天要解决的：面向接口调用、安全、路由、配置文件**
- 什么是注册中心Eureka，注册中心解决了什么问题？
  - 注册中心是实现服务注册和发现功能，包含了服务端，和客户端组件。
  - 解决了服务治理的问题
- 什么是负载均衡Ribbon，负载均衡解决了什么问题？
  - 负载均衡器是一个工具框架，实现了Http客户端负载均衡的工具。基于Netflix Ribbon实现。常用算法有轮询、随机、AvailabilityFilteringRule【默认】。
  - 解决了集群并发访问的优先级问题
- 什么是熔断器Hystrix，熔断器解决了什么问题？
  - 熔断器Hystrix是服务的一种自我保护机制，提升服务的容错性能，它也是Netflix公司的一款组件，后被SpringCloud收入囊中。
  - 它为服务的延迟和故障提供一种保护机制，防止服务出现级联出错，提高分布式系统整体的弹性。

## 今日授课目标：

1. 能够使用Feign进行远程调用【重点】
2. 能够搭建Spring Cloud Gateway【重点】
   - 能够配置Spring Cloud Gateway过滤器
   - 能够编写Spring Cloud Gateway全局过滤器
3. 能够搭建Spring Cloud Config配置中心服务【重点】


# 一、Spring Cloud Feign 远程过程调用

简介

- 什么是Feign？
  - 一个http请求调用的轻量级框架，目标是以Java接口的方式调用Http接口。
  - 封装了Http调用流程，使其更符合面向接口化的编程习惯(类似于Dubbo)
- 为什么是Feign？
  - 通过入门案例的代码体会其与RestTemplate的区别，是不是Feign更优秀，更加的Write less do more呢？！
  - 无感知的负载均衡实现，可复用的接口，接口的分类抽取和封装，以及见文知意！

## 入门案例

目标：使用Feign替代RestTemplate发送Rest请求。使之更符合面向接口化的编程习惯。

实现步骤：

1. 导入依赖Feign的starter
2. 启动引导类加@EnableFeignClients注解
3. 编写FeignClient接口，使用SpringMVC的注解
4. 在Controller中注入Feign接口，直接调用，无需实现类
5. 访问接口测试

## 实现原理分析

- 参考PPT中原理分析图

## 负载均衡

- 负载均衡：Feign本身集成了负载均衡Ribbon，因此不需要额外引入依赖，即可无感知使用负载均衡。
  - 通过集群用户服务测试效果

## 请求压缩和响应压缩，日志配置

- 为什么需要压缩？
  - 对请求和响应压缩，以提升通信过程中的传输速度
- 日志配置：Feign的日志配置较为特殊
  - 实现步骤：
    - 配置文件中开启日志级别配置
    - 编写配置类，定义日志级别
    - 在@FeignClient中指定配置类
    - 重启项目测试效果

## 熔断器

熔断器：Feign本身集成了熔断器Hystrix，因此也不需要引入依赖，就可以使用熔断器。

使用步骤：

- 配置中开启Feign的支持
- 编写服务降级处理类(注意不是方法)，类必须实现其@FeignClient接口
- 在@FeignClient注解中，指定FallBack处理类
- 测试服务降级效果

# 二、Spring Cloud Gateway 网关

## 什么是Gateway

- Gateway网关是我们服务的守门神，所有微服务的统一入口
- 旨在为微服务架构提供一种简单有效的API路由管理方式
- 提供网关的基本功能：安全，监控，限流
- 本身就是一个微服务，需要注册到注册中心

核心术语

- Route路由：网关的基本模块：包含ID，目标URI，断言和过滤器
- Predicate断言：路由的规则
- Filter过滤器：过滤请求

## 入门案例

- 目标：搭建网关微服务，实现服务路由分发。
- 实现步骤：
  1. 创建SpringBoot工程Gateway_server
  2. 勾选starter：网关、Eureka客户端
  3. 编写基础配置：端口，应用名称，注册中心地址
  4. 编写路由规则：唯一表示id，路由url地址，路由限定规则
  5. 启动网关服务进行测试

## 动态路由、路由前缀

- 动态路由
  - 如果把路径对应服务地址写死，那么微服务是集群的话，这样做很不合理！怎么办？--动态路由
  - 配置方式是`uri: lb://user-service`改为lb协议+服务名称

- 路由前缀
  - 添加前缀：
    - `- PrefixPath=/user`
  - 去除前缀：
    - ` - StripPrefix=1`

## 过滤器介绍及全局过滤器配置

- 什么是过滤器？
  - 过滤器实际上就是对web资源进行拦截，做些处理。
  - 过滤器作为网关的其中一个重要功能，就是实现请求的鉴权。
- 使用场景
  - ==请求鉴权：如果没有访问权限，直接进行拦截==
  - 异常处理：记录异常日志
  - 服务调用时长统计
- 过滤配置
  - 局部过滤器：只作用在当前配置的路由上。
  - 全局过滤器：作用在所有路由上。

## 自定义过滤器

- 目标：模拟登录校验。
- 实现步骤：
  1. 在Gateway_server工程编写全局过滤器类MyGlobalFilter
  2. 编写业务逻辑代码判断
     - 过滤器必须注入SpringIOC容器中
     - 如果请求中有token参数，则认为请求有效，放行，
     - 如果没有则拦截提示未授权。
  3. 访问接口测试，加token和不加token。

总结：

- 什么是Gateway？
  - Gateway网关是我们服务的守门神，所有微服务的统一入口。旨在为微服务架构提供一种简单有效的API路由管理方式。提供网关的基本功能：安全，监控，限流

  - Route路由：网关的基本模块：包含ID，目标URI，断言和过滤器
  - Predicate断言：路由的规则
  - Filter过滤器：过滤请求
- 动态路由：如果把路径对应服务地址写死，那么微服务是集群的话，这样做很不合理！怎么办？--动态路由。配置方式是`uri: lb://user-service`改为lb协议+服务名称
- 路由前缀，添加前缀`- PrefixPath=/user`，去除前缀` - StripPrefix=1`
- 什么是过滤器？
  - 过滤器实际上就是对web资源进行拦截，做些处理。过滤器作为网关的其中一个重要功能，就是实现请求的鉴权。

# 三、Spring Cloud Config 配置中心

## 什么是配置中心

- 统一管理所有微服务配置文件的一个微服务
- 配置中心，也是一个微服务，需要注册到注册中心

## 配置文件托管到码云

- 目标：配置文件集中放在码云
- 实现步骤：
  1. 创建远程仓库
  2. 在码云新增空配置文件：user-dev.yml
  3. 然后将本地user-service服务的配置文件复制到user-dev.yml

## 搭建配置中心微服务

- 目标：搭建配置中心微服务
  - 配置中心的从码云拉取配置文件
- 实现步骤：
  1. 创建配置中心SpringBoot项目Config_server
  2. 勾选Starter：配置中心，Eureka客户端
  3. 在启动引导类上加@EnableConfigServer注解
  4. 修改配置文件：端口，应用名称，注册中心地址，码云仓库地址
  5. 启动测试，测试配置文件实时同步

## 微服务获取配置中心配置文件

- 目标：改造user_service工程，配置文件不再由微服务项目提供，而是从配置中心获取。
- 实现步骤：
  1. 在user_service服务中，添加配置中心的starter依赖
  2. 删除application.yml配置文件，新增bootstrap.yml配置文件
  3. 配置bootstrap.yml配置文件：
     - 配置中心相关配置(配置文件前缀、后缀，仓库分支，是否开启配置中心)
     - 注册中心地址
  4. 启动服务，测试效果
- 存在的问题，复现
  - 仓库的配置文件修改了，并没有实时生效。

# 四、Spring Cloud Bus 消息总线

## 什么是消息总线Bus

Bus是轻量级消息代理的框架，主要用于广播配置文件的更改或服务的监控管理。

- 本身不支持消息分接收和发送，使用消息代理来完成这部分功能。可选的有RabbitMQ或Kafka。

## RabbitMQ的安装

参考资料中的安装文档<<安装Windows RabbitMQ.pdf>>

## 整合案例

- 目标：消息总线整合入微服务系统，实现配置中心的配置自动更新。不需要重启微服务。
- 实现步骤：
  - 改造配置中心
    - 在Config_server中，加入Bus和RabbitMQ的依赖
    - 修改配置文件：RabbitMQ服务地址，触发配置文件更改接口
  - 改造用户服务
    - 在user-service中，加入Bus和RabbitMQ的依赖
    - 修改配置文件：RabbitMQ服务地址
    - 在需要刷新配置的类上加@RefreshScope注解
    - 测试效果

# 今日总结

1. 能够使用Feign进行远程调用【重点】

   - 负载均衡、熔断器

   - 请求压缩及响应压缩
   - 日志配置

2. 能够搭建Spring Cloud Gateway【重点】

   - 动态路由

   - 路由前缀

   - 能够配置Spring Cloud Gateway过滤器

   - 能够编写Spring Cloud Gateway全局过滤器【难点，也是重点】

3. 能够搭建Spring Cloud Config配置中心服务【重点】

   - 配置中心服务端

   - 配置中心客户端

## How-to

- 什么是SpringCloud?
  - 它是一系列框架的有序集合，利用SpringBoot开发的便利巧妙的简化了分布式系统的开发。常用的有负载均衡器、断路器、注册中心、配置中心、远程过程调用Feign。
  - SpringCloud从架构层面降低了大型分布式系统的构建难度和要求
- 微服务业务场景中，必然面临的问题有什么？
  - 服务治理、负载均衡、容错、远程调用
  - 除此之外还有今天要解决的：面向接口调用、安全、路由、配置文件
- 什么是注册中心Eureka，注册中心解决了什么问题？
  - 注册中心是实现服务注册和发现功能，包含了服务端，和客户端组件。
  - 解决了服务治理的问题
- 什么是负载均衡Ribbon，负载均衡解决了什么问题？
  - 负载均衡器是一个工具框架，实现了Http客户端负载均衡的工具。基于Netflix Ribbon实现。常用算法有轮询、随机。
  - 解决了集群并发访问的优先级问题(负载均衡的问题)
- 什么是熔断器Hystrix，熔断器解决了什么问题？
  - 熔断器Hystrix是服务的一种自我保护机制，提升服务的容错性能，它也是Netflix公司的一款组件，后被SpringCloud收入囊中。它为服务的延迟和故障提供一种保护机制，防止服务出现级联出错，提高分布式系统整体的弹性。
  - 熔断器解决了系统容错的问题
- 什么是远程调用Feign，解决了什么问题？
  - 一个http请求调用的轻量级框架，目标是以Java接口的方式调用Http接口。封装了Http调用流程，使其更符合面向接口化的编程习惯(类似于Dubbo)
  - Feign比RestTemplate更优秀，更加的Write less do more！feign有无感知的负载均衡实现，可复用的接口，接口的分类抽取和封装，以及见文知意！
- 什么是网关Gateway，网关解决了什么问题？
  - Gateway网关是我们服务的守门神，所有微服务的统一入口
  - 旨在为微服务架构提供一种简单有效的API路由管理方式
- 什么是配置中心Config，配置中心解决了什么问题？
  - 统一管理所有微服务配置文件的一个微服务
  - 解决配置文件的管理问题
- 什么是消息总线Bus，消息总线解决了什么问题？
  - 是轻量级消息代理的框架，主要用于广播配置文件的更改。
  - 配置文件的值热加载的问题